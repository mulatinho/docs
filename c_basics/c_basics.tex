\documentclass{beamer}
\usepackage{graphicx,url,verbatim,fancyvrb,ifpdf}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{draftwatermark}

\setbeamercolor{background canvas}{bg=}

\mode<presentation>
{ \usetheme{Warsaw} }

\title[Introdução ao desenvolvimento em ambientes Unix]{Conceitos básicos para desenvolvimento de sistemas em ambiente Linux}
\author{Alexandre Mulatinho\\ E-mail: alex@mulatinho.net}
\institute{Mulatinho's Weblog\\ http://alex.mulatinho.net\\ Twitter: @alexmulatinho}


\begin{document}

\SetWatermarkText{http://alex.mulatinho.net}
\SetWatermarkLightness{0.85}
\SetWatermarkScale{0.5}

\maketitle

\begin{frame}
	\frametitle{Antes de mais nada...}
	\begin{columns}[T]
		\begin{column}{0.3\linewidth}
			\Large{\textbf{Há quem se destina estes slides?}}
		\end{column}
		\begin{column}{0.7\linewidth}
			\normalsize
			\begin{itemize}
				\item Iniciantes no mundo Unix/Linux.
				\item Profissionais em busca de mais conhecimento
				em desenvolvimento utilizando ferramentas livres.
				\item Quem quer aprender o básico sobre:
				\begin{itemize}
					\item a linguagem C,
					\item desenvolvimento,
					\item controle de versões e 
					\item debug em sistemas Unix.
				\end{itemize}
				\item Entusiastas do uso de software livre!
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{\$ whoami}
	\begin{columns}[T]
		\begin{column}{0.6\linewidth}
			\begin{itemize}
				\item Atualmente Analista de Suporte
				\item 10 (dez) anos trabalhando no mercado de TI como desenvolvedor,
				administrador de sistemas e analista de suporte em geral.
				\item Certificado Linux - LPIC-1 / LPIC-2
				\item Ativista no uso de Software Livre
				\item Desenvolvedor C, PHP e Shell script. Bom interpretador de outras linguagens ;)
			\end{itemize}
		\end{column}
		\begin{column}{0.4\linewidth}
			\begin{figure}
				\includegraphics[width=0.7\textwidth]{imgs/mlt.jpg}
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{\textbf{Conceitos Básicos}}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Conceitos Básicos}
	\begin{itemize}
		\item\Large{O que é um programa?}
		\begin{itemize}
			\item Uma série de instruções utilizando uma linguagem 
			de programação dentro de uma máquina capaz de interpretá-las e 
			processá-las com um objetivo específico.
		\end{itemize}
		\item\Large{Como ele é feito?}
		\begin{itemize}
			\item No final um programa é constituído de "0"s e "1"s
			e só é entendido pelo computador, seria inviável desenvolvermos algo
			assim e por isso foram definidas palavras por programadores que contendo
			uma lógica adequada constroem um programa de computador.
		\end{itemize}
		\item\Large{Quais ferramentas utilizo para desenvolvê-lo?}
		\begin{itemize}
			\item Basicamente você precisa de três coisas: um editor
			para construir o seu código, um compilador que transformará o seu código 
			em um objeto e um linker que ira traduzir o objeto gerado para um 
			binário entendido pela a arquitetura do seu computador.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Conceitos Básicos}
	Então agora que já sabemos o que é um programa de computador devemos definir que
	tipos de programa existem e para quê propósito eles foram criados, tendo como
	base estas afirmações podemos classificar os programas em dois tipos:
	
	\begin{itemize}
		\item<1-> Software de sistema: são programas de computadores críticos e que
		trabalham entre a camada de hardware e software, eles são utilizados pelo 
		usuário constantemente, embora usuários leigos não tenham ciência disso 
		pois é necessário que os softwares de aplicativo façam a ponte entre eles. 
		\begin{itemize}
			\item<2-| alert@2> Exemplos: Firmwares, RTOS, drivers de dispositivos.
		\end{itemize}
		\item<1-> Software aplicativo: esses são os nossos softwares do dia a dia,
		que todo o usuário gosta de usar e hoje devido a necessidade de tecnologia
		nós seres humanos não vivemos sem eles.
		\begin{itemize}
			\item<3-| alert@3> Exemplos: VIM, AWK, Firefox, Eclipse, Java, C, 
		\end{itemize}
	\end{itemize}
	
	\onslide<3>{Nesta apresentação iremos focar apenas no segundo tipo.}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{\textbf{Ferramentas importantes}}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Ferramentas importantes}
	
	\only<1>{
	Para que você seja eficiente desenvolvendo uma aplicação você deve obtêr 
	algumas ferramentas que serão úteis durante todo o processo, algumas delas
	vamos discutir mais a frente, outras não, eis aqui algumas delas:
	
	\begin{description}
		\item[Editor de texto] Aqui vale a pena perder algumas horas escolhendo
		um editor que mais se adeque ao seu estilo, hoje em dia com a febre dos
		IDEs é difícil encontrar quem consiga programar sem um deles, aqui 
		particularmente eu utilizo o VIM e algumas vezes o Geany.
		\item[Compilador] Para que seu código depois de editado se transforme em
		um binário e você possa executá-lo é crítico escolher o compilador adequado,
		infelizmente muitas vezes aqui você não terá opção, principalmente se 
		estiver trabalhando com sistemas embarcados.
	\end{description}
	}
	\only<2>{
	\begin{description}
		\item[Controle de versão] Muitas vezes iniciantes de programação ou até 
		programadores experientes ignoram o fato de que devem ter controle sobre
		suas versões de desenvolvimento, quando percebem que isto é muito importante
		já estão com o projeto todo bagunçado e é muito pior corrigir depois.
		\item[Diagnóstico] Muito úteis para analisar os binários como os debuggers,
		aqui também se encaixariam ferramentas de trace como o strace, ltrace. 
		\item[Auxiliares] Ferramentas de auxílio como o autotools que geram para
		você scripts de configuração, compilação, etc. são cruciais para fazer você
		não perder tempo com rotinas mecânicas.
		\end{description}
	}
	\only<3>{
	\begin{itemize}
		\item Editores de texto
		\begin{itemize}
			\item<alert@3> VIM, LaTeX, Eclipse, Geany, Emacs, MS Visual C++, etc.
		\end{itemize}
		\item Compiladores
		\begin{itemize}
			\item<alert@3> GCC, Visual C++, TinyC, LLVM-Clang, etc.
		\end{itemize}
		\item Controles de Versão
		\begin{itemize}
			\item<alert@3> Git, Subversion, Mercurial, CVS, etc.
		\end{itemize}
		\item Diagnóstico
		\begin{itemize}
			\item<alert@3> GDB, binutils, strace, ltrace, etc.
		\end{itemize}
		\item Auxiliares
		\begin{itemize}
			\item<alert@3> Autoconf, Automake, Scripts Shell ou Batch, QMake, etc.
		\end{itemize}
	\end{itemize}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{\textbf{Um pouco de história}}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Um pouco de história}
	Talvez seja difícil de imaginar para alguns mas até 1970, exceto em alguns programas
	específicos escritos nas linguagens "modernas" da epóca BASIC, COBOL, BCPL, etc., 
	todos os outros eram escritos em Assembly, mais ou menos assim:
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{linux x86 assembly}
				\VerbatimInput[xleftmargin=8mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex01.txt}
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{z80 assembly}
				\VerbatimInput[xleftmargin=8mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex03.txt}
			\end{block}
		\end{column}
	\end{columns}
	
	Na epóca em que desenvolver era função de programadores de verdade que tinham que
	lêr os manuais de arquitetura do processador, gerenciar a memória de seus programas, etc.
	Hoje a realidade é bem diferente, utilizamos bibliotecas e funções desenvolvidas
	por terceiros e as adequamos aos nossos programas.
\end{frame}

\begin{frame}
	\frametitle{Um pouco de história}
	\framesubtitle{E onde está o C nisso!?}
	\begin{columns}[T]
		\begin{column}{0.5\linewidth}
			\begin{itemize}
				\item Criado por Dennis Ritchie e Ken Thompson no período dos anos 
				de 1969 até 1972.
				\item Estruturada, imperativa, procedural e padronizada pela ISO.
				\item Utilizada em baixo nível e alto nível.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{figure}
				\includegraphics[width=0.75\textwidth]{imgs/pdp11-70-front.jpg}
			\end{figure}
		\end{column}
	\end{columns}
	
	\vskip 5mm
	
	A maioria dos sistemas operacionais modernos são escritos em C, por ser capaz
	de realizar abstrações, mexer com bits e bytes e controlar de forma eficiente
	a memória. C é simplesmente a linguagem que criou o Unix, o Linux, o Windows, 
	o Java e vários outros programas utilizados até hoje.
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{\textbf{Uma rápida introdução ao C}}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Uma rápida introdução ao C}
    \only<1> {
    \framesubtitle{Tipos de dados}
    A linguagem de programação C, diferente das linguagens modernas, possui
    apenas 32 (trinta e duas) palavras reservadas por padrão. São elas:

    \begin{center}
    \begin{tabular}{c c c c c c}
        auto & break & case & char & const & continue \\
        default & do & double & else & enum & extern \\
        float & for & goto & if & int & long \\
        register & return & short & signed & sizeof & static \\
        struct & switch & typedef & union & unsigned & void \\
        volatile & while
    \end{tabular}
    \end{center}

    Destas palavras cinco delas são tipos de dados:

    \begin{center}
    \begin{tabular}{c c c c c}
        char & int & float & void & double
    \end{tabular}
    \end{center}

    Para cada tipo de dado também existem modificadores como:

    \begin{center}
    \begin{tabular}{c c c c c c}
        . & signed & unsigned & long & short & .\\
        \color{red} volatile & \color{red} extern & \color{red} register & 
        \color{red} auto & \color{red} const & \color{red} static
    \end{tabular}
    \end{center}
    }

    \only<2> {
    \framesubtitle{Estrutura básica e declarações de variáveis}
	Um programa em C comum contém a seguinte estrutura
	
	\begin{enumerate}
		\item Comando do pré processador.
		\item Tipos de dados definidos globalmente.
		\item Protótipos de funções.
		\item Funções e variáveis locais das funções.
	\end{enumerate}
	
	Definição de variáveis em C e seus tamanhos reais em bytes
	
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{Declarações simples}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/c_variables.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Tamanho de tipos de dados}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/c_sizeof.txt}
			\end{block}
		\end{column}
	\end{columns}
	}

	\only<3>{
	\framesubtitle{Fluxos de controle em C}

	Fluxos de controle são comandos que desviam o programa dependendo de alguma
	condição ou iteração, em C existem cinco palavras chaves para executar desvios
	e iterações no seu programa, são elas:
	
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{O comando 'while'e o 'do-while'}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/loops.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{O comando 'for', o 'break' e 'continue'}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/loops02.txt}
			\end{block}
			\begin{itemize}
				\item break, para a execução do loop.
				\item continue, vai para próxima iteração.
			\end{itemize}
		\end{column}
	\end{columns}
	
	}
	
	\only<4> {
	\framesubtitle{If-then-else e o operador '?'}
	
	As formas mais simples de criar condições em C são através do famoso if-then-else
	e do operador '?', vamos aos exemplos.
	
	\begin{block}{If-then-else e o operador '?'}
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/condicoes.txt}
	\end{block}
	
	Não há muito o que dizer aqui em relação ao if-then-else, o operador '?' realiza
	um teste na expressão à esquerda e se a condição for falsa retorna o primeiro valor 
	depois do operador ou se verdadeira, o segundo valor após os ':' (dois pontos).
	}
	
	\only<5> {
	\framesubtitle{O comando switch}
	O switch é chamado de 'if elegante', ele não é tão poderoso pois trata apenas
	expressões simples e geralmente apenas variáveis, é muito utilizado para 
	selecionar opções em loops de menu.
	
	\begin{block}{Switch}
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/condicoes02.txt}
	\end{block}
	
	O case sempre deve ser um número ou um hash, lembrando que em C um número também
	pode ser uma letra como em 'A', 'B' ou 'C'.
	}
	
	\only<6>{
	
	\begin{columns}[T]
		\begin{column}{0.25\linewidth}
			Funções
			\begin{itemize}
				\scriptsize
				\item Protótipo é escrito de forma resumida no início dos fontes.
				\item O retorno da função pode ser void (nada) ou um tipo de dado.
			\end{itemize}
		\end{column}
		\begin{column}{0.75\linewidth}
			\begin{figure}
				\includegraphics[width=220,height=110]{imgs/funcoes.png}
			\end{figure}
		\end{column}
	\end{columns}
	
	Estruturas
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{Declaração de Struct}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/struct01.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Usando novos tipos de dados}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/struct02.txt}
			\end{block}
		\end{column}
	\end{columns}
	}
	
	\only<7>{
	\framesubtitle{Ponteiros e alocação dinâmica de memória}
	\begin{columns}[T]
	\begin{column}{0.7\linewidth}
	Um dos maiores problemas para programadores iniciantes em C é a questão dos
	ponteiros, para ajudar a entender podemos fazer algumas afirmações:

	\begin{itemize}
		\scriptsize
		\item A memória alocada é segmentada de forma linear.
%		\item Por padrão, é separada em páginas de 4KB.
%		\item A razão do limite de memória é definida
%		pela tamanho da página vezes o tamanho virtual
%		de endereçamento.
		\item Em C quando usamos o operador \&var estamos
		dizendo 'o endereço da memória do ponteiro var', e quando usamos o
		operador *var estamos dizendo 'o valor contido no 
		ponteiro var'.
	\end{itemize}
	\end{column}
	
	\begin{column}{0.3\linewidth}
		\begin{figure}
			\includegraphics[width=0.75\linewidth]{imgs/pointers.png}
		\end{figure}
	\end{column}
	\end{columns}
	
	\begin{block}{Alocação Dinâmica de Memória}
		char *ptr = malloc(100);\\
		int *nptr = malloc(sizeof(int) * 50);\\
		nptr = realloc(\&nptr, (sizeof(int) * 75));
	\end{block}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{\textbf{Desenvolvendo programas}}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Desenvolvendo programas}
	
	\only<1>{
	Vamos fazer o clássico "Hello World" para começar, ele simplesmente imprime
	o texto na saída do monitor, podemos vêr a estrutura básica de um programa 
	em C e como o compilamos.
	
	\VerbatimInput[xleftmargin=15mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex02.txt}
	
	Duas coisas a comentar aqui: 
	
	\begin{itemize}
	\item A palavra \#include é utilizada para incluir bibliotecas.
	\item Palavras em C terminam suas declarações com um ';' (ponto e 
	virgula) exceto alguns fluxos de controles como: if, while, else.
	\end{itemize}
	
	\begin{block}{Compilando e rodando o programa}
	\scriptsize
	\$ gcc -o prog1 prog1.c\\
	\$ ./prog1\\
	Ola meu jovem!
	\end{block}
	}
	
	\only<2>{
	Dessa vez vamos complicar um pouquinho mais, o objetivo do programa é encontrar
	entre dois números qual é o maior, para isso separamos o programa em três 
	arquivos distintos:
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{func01.c}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/func01.c}
			\end{block}
			\begin{block}{Como compilar}
				\$ gcc -o func01.o -c func01.c\\
				\$ gcc -o func02.o -c func02.c\\
				\$ gcc -o func func01.o func02.o
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{headers.h}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/headers.h}
			\end{block}
			\begin{block}{func02.c}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/func02.c}
			\end{block}
		\end{column}
	\end{columns}
	}
	
	\only<3>{
	\framesubtitle{Um simples Makefile para projetos pequenos}
	
	Para automatizar nosso processo de compilação em projetos pequenos nós criamos
	um arquivo chamado Makefile. Abaixo podemos ver um exemplo com quatro fontes 
	distintos e três alvos diferentes para o comando 'make'
	
	\begin{block}{Makefile}
		\scriptsize
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/Makefile}
	\end{block}
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\tiny
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make clean
			\end{exampleblock}
		\end{column}
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make test
			\end{exampleblock}
		\end{column}
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make
			\end{exampleblock}
		\end{column}
	\end{columns}
	}
	
	\only<4> {
		\framesubtitle{Bibliotecas comuns}
		\begin{block}{Tabela de bibliotecas C ANSI C99}
		\begin{tabular}{c l}
			\scriptsize
			assert.h &  detecção de erros lógicos dentro dos programas\\
			errno.h & códigos de erro de funções de outras bibliotecas\\
			limits.h & constantes númericas padrões no ANSI C\\
			locale.h & internacionalização de textos e caracteres\\
			math.h & funções matemáticas úteis em C\\
			signal.h & sinalização de eventos e sinais\\
			\textbf{stdio.h} & \textbf{biblioteca de entrada e saída de dados padrão}\\
			string.h & manipulação de strings\\
			stdlib.h & alocação de memória, números randomicos, etc.\\
		\end{tabular}
		\end{block}
		
		Compilando código com biblitoecas alternativas
		
		\vspace{-\lineskip}
		\begin{columns}[T]
			\tiny
			\begin{column}{0.5\linewidth}
			\begin{exampleblock}{Utilizando POSIX Threads}
				\$ gcc -o prog prog.c \textbf{-lpthread}
			\end{exampleblock}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{exampleblock}{Utilizando GTK no gráfico}
				\$ gcc -o gtktest gtktest.c \textbf{`pkg-config --cflags --libs gtk+-2.0`}
			\end{exampleblock}
		\end{column}
	\end{columns}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{\textbf{Utilizando controle de versões}}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Utilizando controle de versões}
	\only<1>{
	Hoje em dia desenvolver qualquer coisa com mais de mil linhas de código sem
	um controlador de versões é confusão na certa, ainda mais se esse código 
	precisa ser compartilhado e desenvolvido por mais de uma pessoa. 
	
	\begin{block}{Definição}
	Como o próprio nome diz ele serve para guardar informações (autor, o que foi
	modificado, quando foi modificado, comentários de porque houve a modificação)
	sobre um determinado arquivo ou projeto em um intervalo de tempo, dando 
	possibilidade aos integradores de juntar versões diferentes ou voltar a uma
	determinada versão gerada em uma linha de tempo.
	\end{block}
	
	Imagine um projeto do tamanho do Linux com mais de 5 milhões de linhas sem um
	controlador de versão para mandar pra dentro o que a galera adiciona ao código!?!?
	}
	
	\only<2>{
	Principais características encontradas nos controladores de versão
	
	\begin{itemize}
		\item Desenvolvimento descentralizado.
		\item Marcações de momentos importantes.
		\item Controle de histórico dos arquivos do projeto.
		\item Linhas de desenvolvimento paralelas(estável, instável) ou branches 
		para adição de novas funcionalidades.
		\item Otimização de espaço, velocidade de transações, locks exclusivos.
	\end{itemize}
	
	Infelizmente não poderemos vêr todas as vantagens aqui, o assunto sobre 
	controle de versões é bastante amplo e deve ficar para uma apresentação 
	específica. Mas vamos a algumas dicas....
	}
	
	\only<3>{
	\begin{columns}[T]
		\begin{column}{0.5\linewidth}
			\begin{itemize}
				\item Imagine o gráfico ao lado como a linha de desenvolvimento
				de software.
				\item Note a linha do tempo de cima para baixo.
				\item Os itens de cor:
			\end{itemize}
			
			\begin{description}
				\setlength{\itemindent}{2pt}
				\scriptsize
				\item[Azul] Representam as releases, as tags/versões oficiais do 
				produto.
				\item[Amarelo] Desenvolvimento bruto, onde são adicionados
				itens ao projeto.
				\item[Rosa] Novas ramificações, onde são desenvolvidos itens 
				antes de entrar nas versões de desenvolvimento e ou release de 
				versões.
			\end{description}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{figure}
				\includegraphics[height=200]{imgs/vcs.png}
			\end{figure}
		\end{column}
	\end{columns}
	}
	
	\only<4>{
	\framesubtitle{GIT, criado por Linus Torvalds.}
	
	Abaixo podemos ver uma lista de exemplos de comando do GIT e seus significados,
	acredite depois de um ou dois dias mexendo isso se torna fácil e muito útil no
	seu dia a dia.
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{Cria um repositório GIT}
			\$ cd projetos/super-secreto \&\& git init
			\end{block}
			
			\begin{block}{Clona um repositório remoto para a máquina local}
			\$ git clone https://github.com/mulatinho/sfm.git 
			\end{block}
			
			\begin{block}{Verifica as mudanças feitas no diretório local}
			\$ git status 
			\end{block}
			
			\begin{block}{Pega as atualizações do repositório original}
			\$ git pull 
			\end{block}
			
			\begin{block}{Mostra as diferenças feitas no arquivo "libsmb.c"}
			\$ git diff libsmb.c 
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Faz commit do arquivo "libsmb.c"}
			\$ git commit -m '2 novas funcoes' libsmb.c 
			\end{block}
			
			\begin{block}{Envia suas modificações ao repositório remoto}
			\$ git push origin master 
			\end{block}
			
			\begin{block}{Lista branchs criadas}
			\$ git branch 
			\end{block}
			
			\begin{block}{Cria branch "cpp-list"}
			\$ git branch cpp-list 
			\end{block}
			
			\begin{block}{Lista todas as tags do repositório}
			\$ git tag -l 
			\end{block}
		\end{column}
	\end{columns}
	\normalsize
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{\textbf{Utilizando o autotools}}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Utilizando o autotools}
	
	\only<1>{
	Lembra como compilar um programa? Como gerar um Makefile!? Agora imagine se 
	você tivesse que compilar mais de trinta arquivos um a um e depois fazer o link
	dos objetos na mão, centenas de vezes, quantas vezes você erraria a ordem de
	compilação? esqueceria um ou outro fonte/objeto? Para evitar que isso aconteça
	e que você não precise sempre realizar esse trabalho de maluco, a GNU 
	desenvolveu a ferramenta chamada \textbf{autotools}.
	
	\begin{block}{Quem nunca fez!?}
		\$ ./configure\\
		\$ make\\
		\$ make install
	\end{block}
	
	Apesar de eles serem scripts shell que auxiliam o usuário a gerar o binário
	apartir dos códigos de fonte, eles não são gerados manualmente pelos programadores
	do projeto.
	}
	
	\only<2>{
	Principais módulos da ferramenta autotools
	
	\begin{description}
		\item[Autoconf] Responsável por gerar o arquivo 'configure', muito útil
		na hora de compilar o projeto pois ele checa se todos os pré-requisitos
		foram atentidos, caso não tenham sido ele geralmente retorna ao usuário
		o software, função, etc. que está faltando para compilar o projeto.
		\item[Automake] Apartir dos arquivos de entrada do \texttt{'Makefile.am'}
		ele gera o famoso 'Makefile' que é responsável por processar os comandos
		do usuário 'make' e 'make install'.
		\item[Libtool] Geralmente utilizado em conjunto com o autoconf e o automake,
		o libtool faz a função de cross compiler, apartir das entradas do 
		\texttt{'./configure'} e passando argumentos como \texttt{'--arch'} é
		possível especificar para que arquitetura será compilado o projeto.
	\end{description}
	
	}
	
	\only<3> {
	Com apenas a edição de dois arquivos, 
	
	\begin{itemize}
		\item 'Makefile.am'
		\item 'configure.ac'
	\end{itemize}
	
	e mais três comandos (listados abaixo) geramos de forma eficiente no nosso
	projeto o sistema de builds da GNU, tornando nossa vida mais fácil.
	
	\begin{block}{Utilizando o sistema de builds da GNU passo-a-passo}
		\scriptsize
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/ex04.txt}
	\end{block}
	
	Então, como gerar os arquivos necessários para o projeto!?
	}
	
	\only<4>{
	\framesubtitle{O arquivo de entrada 'Makefile.am'}
	Arquivos do projeto:
	
	\begin{tabular}{c c c c c}
		Makefile.am & configure.ac & func01.c & func02.c & headers.h \\
	\end{tabular}
	
	\vskip 5mm
	
	O arquivo 'Makefile.am' é a entrada que contém a especificação de todos os seus
	fontes, bibliotecas de compilação (CFLAGS e LDADD), arquivos de documentação
	e arquivos comuns do projeto, além de diretórios para build, etc. Vejamos um 
	exemplo bem básico abaixo de seu conteúdo:
	
	\begin{block}{Makefile.am}
		\scriptsize
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/Makefile.am}
	\end{block}
	
	}
	
	\only<5>{
	\framesubtitle{O arquivo de entrada 'configure.ac'}
	Um típico arquivo 'configure.ac' é a entrada para os comandos aclocal e autoconf, 
	ele é definido usando a descrição macro m4 e não é tão difícil de entender depois
	de alguns minutos lendo sua documentação, vejamos um exemplo:
	
	\begin{block}{configure.ac}
		\scriptsize
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/configure.ac}
	\end{block}
	}
	
	\only<6> {
	\framesubtitle{Gerando o build do projeto}
	\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/ex05.txt}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{\textbf{Debugando seu código}}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}[t]
	\frametitle{Debugando seu código}
	\only<1>{
		\framesubtitle{Por quê debugar??}
		
		Debugar é o ato de confirmar que algo que você pensa que é verdadeiro
		de fato o é, ou que, provando passo a passo você descubra que algo não é
		tão verdadeiro quanto você pensava ser.
		
		\vskip 5mm
		
		Um bug nada mais do que uma condição de erro, falha ou algo que é inesperado
		numa série de rotinas que deveriam seguir uma lógica conhecida. Debugar então
		é necessário para confirmar que seu programa está seguindo todas as rotinas
		que você escreveu sem condições desconhecidas a você.
		
		\vskip 5mm 
		
		Alguns motivos para debugar:
		\begin{itemize}
			\item Identificar um erro e/ou condição
			\item Acompanhar uma rotina detalhadamente
			\item Determinar loop infinito, execuções de threads, variáveis, etc.
		\end{itemize}
	}
	\only<2>{
		\framesubtitle{Utilizando o GDB}
		O GDB é o projeto da GNU para debugar aplicativos escritos principalmente 
		em C/C++ mas também tem capacidade de interagir com muitas outras linguagens,
		nós vamos focar aqui na ferramenta de console para que você possa entender
		processos básicos na etapa de debug de um programa.
		
		\begin{columns}[T]
			\begin{column}{0.3\linewidth}
				\tiny
				\begin{block}{Compilando programa e rodando no GDB}
					\$ gcc \textbf{-g} -o program1 program1.c\\
					\$ \textbf{gdb} program1\\
					(gdb) run <argv1>...<argvN>
				\end{block}
				Principais erros
				\begin{itemize}
					\item buffer overflow
					\item stack overflow
					\item memory leak
					\item loops, retornos de função, etc.
				\end{itemize}
			\end{column}
			\begin{column}{0.4\linewidth}
				gdb1.c example\\ \hline
				\VerbatimInput[xleftmargin=5mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/gdb2.c}
			\end{column}
			\begin{column}{0.3\linewidth}
				gdb2.c example\\ \hline
				\VerbatimInput[xleftmargin=5mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/gdb1.c}
			\end{column}
		\end{columns}
		
	}
	\only<3>{
		\framesubtitle{Utilizando o GDB, parte 2}

		\begin{table}
		\scriptsize
		\begin{tabular}{c | p{7cm}}
			\textbf{comandos} & \textbf{descrição} \\ \hline
			run & roda o programa em questão, pode usar argumentos. \\ \hline
			break / watch & seta um breakpoint/watchpoint dentro do código fonte. \\ \hline
			step / next & step, adentra na subrotina dentro da função atual. ja
			o next vai para a proxima linha da função atual.\\ \hline
			continue & continua a execução até que o próximo breakpoint seja 
			encontrado no código. \\ \hline
			print / display & imprime o valor de uma variavel, struct, dado.\\ \hline
			info & mostra informações de registradores, variáveis locais, etc.\\ \hline
		\end{tabular}
		\end{table}
		
		\begin{columns}[T]
			\begin{column}{0.5\linewidth}
				\scriptsize
				\begin{exampleblock}{exemplo debugando com gdb, parte 1}
					\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/gdb_saida.txt}
				\end{exampleblock}
			\end{column}
			\begin{column}{0.5\linewidth}
				\scriptsize
				\begin{exampleblock}{exemplo debugando com gdb,parte 2}
					\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/gdb_saida02.txt}
				\end{exampleblock}
			\end{column}
		\end{columns}
	}
	\only<4>{
		Para os que não gostam de comandos de console é claro que temos soluções
		livres e gráficas!! É o estilo do DDD.
		
		\begin{figure}
			\includegraphics[height=180,width=280]{imgs/ddd.png}
		\end{figure}
	}
	\only<5>{
		\framesubtitle{Utilizando o strace}
		O 'strace' é utilizado para rastrear com detalhes ou de forma resumida
		chamadas de sistema executadas dentro de softwares
		
		\begin{itemize}
			\item Chamadas de sistema são requisições de serviços definidos diretamente
			no kernel com uma função específica.
			\item Sempre que você carrega uma biblioteca, lê ou escreve em um arquivo
			você está executando uma chamada do sistema.
			\item No linux as chamadas do sistema estão descritas no cabeçalho
			\textit{/usr/include/asm/unistd.h}.
		\end{itemize}
		
		\vspace{-0.75\baselineskip}
		\begin{block}{Como executar o strace?}
			\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/strace02.txt}
		\end{block}
		
	}
	\only<6>{
		\framesubtitle{Utilizando o strace, parte 2}
		Também podemos analisar detalhadamente cada chamada, abaixo podemos ver
		a simples saída do strace sem muito detalhamento mas que nos ajudam bastante
		
		\VerbatimInput[xleftmargin=5mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/strace.txt}
		
		Alguns itens a observar:
		\begin{itemize}
			\scriptsize
			\item Na linha 2 (dois) é mostrado a execução do comando na shell.
			\item Na linha 3 (três) é carregada uma biblioteca SSL.
			\item Na linha 8 (oito) vemos claramente o retorno -1 da execução do
			programa bem como os argumentos passados pela função connect()
		\end{itemize}
	}
	\only<7>{
		\framesubtitle{Valgrind para memória}
		O valgrind analisa erros de softwares diretamente ligados a memória, é muito
		útil para descobrir memory leaks.
		
		\begin{columns}[T]
			\begin{column}{0.5\linewidth}
				\normalsize
				O código ao lado mostra um programa com dois problemas: um 
				comportamento indefinido (um dos erros mais difíceis de detectar
				sem uma ferramenta adequada em C) e um vazamento de memória devido
				ao alocamento sem liberação.
				
				\begin{itemize}
					\item O valgrind aponta a quantidade de bytes escritos na
					memória que contém erros ou vazamento.
				\end{itemize}
			\end{column}
			\begin{column}{0.5\linewidth}
				\scriptsize
				gdb4.c example\\ \hline
				\VerbatimInput[xleftmargin=5mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/gdb4.c}
				\normalsize
				\begin{itemize}
					\item Identifica a função responsável e a linha dentro do código fonte.
				\end{itemize}
			\end{column}
		\end{columns}
	}
	\only<8>{
		\framesubtitle{Valgrind para memória, parte 2.}
		\begin{column}{0.6\linewidth}
			\normalsize
			\VerbatimInput[xleftmargin=2mm,numbers=left,fontshape=sl,fontsize=\scriptsize]{txtz/valgrind.txt}
		\end{column}
		
		\vskip 5mm
		
		\begin{itemize}
			\scriptsize
			\item Na linha 9 até a linha 11 vemos claramente que houve um vazamento
			de memória provocado pela linha 8 do nosso programa gdb4.c
			\item Finalmente o resumo final confirma o vazamento de memória e informa
			quantos bytes foram perdidos.
		\end{itemize}
	}
\end{frame}

\begin{frame}
	\frametitle{Isso é tudo pessoal!}
    \Huge
    \textbf{Dúvidas e Sugestões?}
    \vskip 10mm
    \normalsize
    Alexandre Mulatinho\\
    Twitter: @alexmulatinho\\
    \space E-mail: alex@mulatinho.net\\
    \space Weblog: http://alex.mulatinho.net\\
\end{frame}

\end{document}
