\documentclass{beamer}
\usepackage{graphicx,url,verbatim,fancyvrb,ifpdf}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{draftwatermark}
%\usepackage[inline]{enumitem}

\setbeamercolor{background canvas}{bg=}

\mode<presentation>
{ \usetheme{Warsaw} }

\title[Introdução ao desenvolvimento em ambientes Unix]{Conceitos básicos para desenvolvimento de sistemas em ambiente Linux}
\author{Alexandre Mulatinho\\ E-mail: alex@mulatinho.net}
\institute{Mulatinho's Weblog\\ http://alex.mulatinho.net\\ Twitter: @alexmulatinho}


\begin{document}

\SetWatermarkText{http://alex.mulatinho.net}
\SetWatermarkLightness{0.85}
\SetWatermarkScale{0.5}

\maketitle

\begin{frame}
	\frametitle{Antes de mais nada...}
	\begin{columns}[T]
		\begin{column}{0.3\linewidth}
			\Large{\textbf{Há quem se destina estes slides?}}
		\end{column}
		\begin{column}{0.7\linewidth}
			\normalsize
			\begin{itemize}
				\item Iniciantes no mundo Unix/Linux.
				\item Profissionais em busca de mais conhecimento
				em desenvolvimento utilizando ferramentas livres.
				\item Quem quer aprender o básico sobre desenvolvimento,
				controle de versões e debug em sistemas Unix.
			\end{itemize}
		\end{column}
	\end{columns}
	
	\vskip 8mm
	
	\begin{columns}[T]
		\begin{column}{0.3\linewidth}
			\Large{\textbf{Quem não deve gostar muito destes slides?}}
		\end{column}
		\begin{column}{0.7\linewidth}
			\normalsize
			\begin{itemize}
				\item Quem já tem bastante experiência em C.
				\item Profissionais que não trabalham com sistemas Unix, Linux, 
				MacOS, *BSD. E nem querem trabalhar!
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{\$ whoami}
	\begin{columns}[T]
		\begin{column}{0.6\linewidth}
			\begin{itemize}
				\item Analista de Suporte
				\item 10 (dez) anos trabalhando no mercado de TI como desenvolvedor,
				administrador de sistemas e analista de suporte em geral.
				\item Certificado Linux - LPIC-1 / LPIC-2
				\item Ativista no uso de Software Livre
				\item Desenvolvedor C, PHP e Shell script. Bom interpretador de outras linguagens ;)
			\end{itemize}
		\end{column}
		\begin{column}{0.4\linewidth}
			\begin{figure}
				\includegraphics[width=120px]{imgs/mlt.jpg}
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{\textbf{Conceitos Básicos}}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Conceitos Básicos}
	\begin{itemize}
		\item<1->\Large{O que é um programa?}
		\begin{itemize}
			\item<2-| alert@2> Uma série de instruções utilizando uma linguagem 
			de programação dentro de uma máquina capaz de interpretá-las e 
			processá-las com um objetivo específico.
		\end{itemize}
		\item<1->\Large{Como ele é feito?}
		\begin{itemize}
			\item<3-| alert@3> No final um programa é constituído de "0"s e "1"s
			e só é entendido pelo computador, seria inviável desenvolvermos algo
			assim e por isso foram definidas palavras por programadores que contendo
			uma lógica adequada constroem um programa de computador.
		\end{itemize}
		\item<1->\Large{Quais ferramentas utilizo para desenvolvê-lo?}
		\begin{itemize}
			\item<4-| alert@4> Basicamente você precisa de três coisas: um editor,
			um compilador que transformará o seu texto editado em um objeto	e um 
			linker que ira traduzir o objeto gerado para um binário entendido pela
			a arquitetura do seu computador.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Conceitos Básicos}
	Então agora que já sabemos o que é um programa de computador devemos definir que
	tipos de programa existem e para quê propósito eles foram criados, tendo como
	base estas afirmações podemos classificar os programas em dois tipos:
	
	\begin{itemize}
		\item<1-> Software de sistema: são programas de computadores críticos e que
		trabalham entre a camada de hardware e software, eles são utilizados pelo 
		usuário constantemente, embora usuários leigos não tenham ciência disso 
		pois é necessário que os softwares de aplicativo façam a ponte entre eles. 
		\begin{itemize}
			\item<2-| alert@2> Exemplos: Firmwares, RTOS, drivers de dispositivos.
		\end{itemize}
		\item<1-> Software aplicativo: esses são os nossos softwares do dia a dia,
		que todo o usuário gosta de usar e hoje devido a necessidade de tecnologia
		nós seres humanos não vivemos sem eles.
		\begin{itemize}
			\item<3-| alert@3> Exemplos: VIM, AWK, Firefox, Eclipse, Java, C, 
		\end{itemize}
	\end{itemize}
	
	\onslide<3>{Nesta apresentação iremos focar apenas no segundo tipo.}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{\textbf{Ferramentas importantes}}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Ferramentas importantes}
	
	\only<1>{
	Para que você seja eficiente desenvolvendo uma aplicação você deve obtêr 
	algumas ferramentas que serão úteis durante todo o processo, algumas delas
	vamos discutir mais a frente, outras não, eis aqui algumas delas:
	
	\begin{description}
		\item[Editor de texto] Aqui vale a pena perder algumas horas escolhendo
		um editor que mais se adeque ao seu estilo, hoje em dia com a febre dos
		IDEs é difícil encontrar quem consiga programar sem um deles, aqui 
		particularmente eu utilizo o VIM e algumas vezes o Geany.
		\item[Compilador] Para que seu código depois de editado se transforme em
		um binário e você possa executá-lo é crítico escolher o compilador adequado,
		infelizmente muitas vezes aqui você não terá opção, principalmente se 
		estiver trabalhando com sistemas embarcados.
	\end{description}
	}
	\only<2>{
	\begin{description}
		\item[Controle de versão] Muitas vezes iniciantes de programação ou até 
		programadores experientes ignoram o fato de que devem ter controle sobre
		suas versões de desenvolvimento, quando percebem que isto é muito importante
		já estão com o projeto todo bagunçado e é muito pior corrigir depois.
		\item[Diagnóstico] Muito úteis para analisar os binários como os debuggers,
		aqui também se encaixariam ferramentas de trace como o strace, ltrace. E até
		quem sabe de áreas específicas como 
		\item[Auxiliares] Ferramentas de auxílio como o autotools que geram para
		você scripts de configuração, compilação, etc. são cruciais para fazer você
		não perder tempo com rotinas mecânicas.
		\end{description}
	}
	\only<3>{
	\begin{itemize}
		\item Editores de texto
		\begin{itemize}
			\item<alert@3> VIM, LaTeX, Eclipse, Geany, Emacs, MS Visual C++, etc.
		\end{itemize}
		\item Compiladores
		\begin{itemize}
			\item<alert@3> GCC, Visual C++, TinyC, LLVM-Clang, etc.
		\end{itemize}
		\item Controles de Versão
		\begin{itemize}
			\item<alert@3> Git, Subversion, Mercurial, CVS, etc.
		\end{itemize}
		\item Diagnóstico
		\begin{itemize}
			\item<alert@3> GDB, binutils, strace, ltrace, etc.
		\end{itemize}
		\item Auxiliares
		\begin{itemize}
			\item<alert@3> Autoconf, Automake, Scripts Shell ou Batch, QMake, etc.
		\end{itemize}
	\end{itemize}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{\textbf{Um pouco de história}}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Um pouco de história}
	Talvez seja difícil de imaginar para alguns mas até 1970, exceto alguns programas
	específicos escritos nas linguagens "modernas" da epóca BASIC, COBOL, BCPL, etc., 
	todos os outros eram escritos em Assembly, mais ou menos assim:
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{linux x86 assembly}
				\VerbatimInput[xleftmargin=8mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex01.txt}
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{z80 assembly}
				\VerbatimInput[xleftmargin=8mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex03.txt}
			\end{block}
		\end{column}
	\end{columns}
	
	Na epóca em que desenvolver era função de programadores de verdade que tinham que
	lêr os manuais de arquitetura do processador, gerenciar a memória de seus programas, etc.
	Hoje a realidade é bem diferente, utilizamos bibliotecas e funções desenvolvidas
	por terceiros e as adequamos aos nossos programas.
\end{frame}

\begin{frame}
	\frametitle{Um pouco de história}
	\begin{columns}[T]
		\begin{column}{0.5\linewidth}
			\begin{itemize}
				\item Criado por Dennis Ritchie e Ken Thompson no período dos anos 
				de 1969 até 1972.
				\item Estruturada, imperativa, procedural e padronizada pela ISO.
				\item Utilizada em baixo nível e alto nível.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{figure}
				\includegraphics[width=150px]{imgs/pdp11-70-front.jpg}
			\end{figure}
		\end{column}
	\end{columns}
	
	\vskip 5mm
	
	A maioria dos sistemas operacionais modernos são escritos em C, por ser capaz
	de realizar abstrações, mexer com bits e bytes e controlar de forma eficiente
	a memória, C é simplesmente a linguagem que criou o Unix, o Linux, o Windows, 
	o Java e vários outros programas utilizados até hoje.
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{\textbf{Uma rápida introdução ao C}}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Uma rápida introdução ao C}
    \only<1> {
    \framesubtitle{Tipos de dados}
    A linguagem de programação C, diferente das linguagens modernas, possui
    apenas 32 (trinta e duas) palavras reservadas por padrão. São elas:

    \begin{center}
    \begin{tabular}{c c c c c c}
        auto & break & case & char & const & continue \\
        default & do & double & else & enum & extern \\
        float & for & goto & if & int & long \\
        register & return & short & signed & sizeof & static \\
        struct & switch & typedef & union & unsigned & void \\
        volatile & while
    \end{tabular}
    \end{center}

    Destas palavras cinco delas são tipos de dados:

    \begin{center}
    \begin{tabular}{c c c c c}
        char & int & float & void & double
    \end{tabular}
    \end{center}

    Para cada tipo de dado também existem modificadores como:

    \begin{center}
    \begin{tabular}{c c c c c c}
        . & signed & unsigned & long & short & .\\
        \color{red} volatile & \color{red} extern & \color{red} register & 
        \color{red} auto & \color{red} const & \color{red} static
    \end{tabular}
    \end{center}
    }

    \only<2> {
    \framesubtitle{Estrutura básica e declarações de variáveis}
	Um programa em C comum contém a seguinte estrutura
	
	\begin{enumerate}
		\item Comando do pré processador.
		\item Tipos de dados definidos globalmente.
		\item Protótipos de funções.
		\item Funções e variáveis locais das funções.
	\end{enumerate}
	
	Definição de variáveis em C e seus tamanhos reais em bytes
	
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{Declarações simples}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/c_variables.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Tamanho de tipos de dados}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/c_sizeof.txt}
			\end{block}
		\end{column}
	\end{columns}
	}

	\only<3>{
	\framesubtitle{Fluxos de controle em C}

	Fluxos de controle são comandos que desviam o programa dependendo de alguma
	condição ou iteração, em C existem cinco palavras chaves para executar desvios
	e iterações no seu programa, são elas:
	
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{O comando 'while'e o 'do-while'}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/loops.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{O comando 'for', o 'break' e 'continue'}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/loops02.txt}
			\end{block}
		\end{column}
	\end{columns}
	
	}
	
	\only<4> {
	\framesubtitle{If-then-else e o operador '?'}
	
	As formas mais simples de criar condições em C são através do famoso if-then-else
	e do operador '?', abaixo podemos ver exemplos de suas declarações.
	
	\begin{block}{If-then-else e o operador '?'}
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/condicoes.txt}
	\end{block}
	
	Não há muito o que dizer aqui em relação ao if-then-else, o operador '?' realiza
	um teste na expressão à esquerda e se a condição for falsa retorna o primeiro valor 
	depois do operador ou se verdadeira, o segundo valor após os ':' (dois pontos).
	}
	
	\only<5> {
	\framesubtitle{O comando switch}
	
	\begin{block}{Switch}
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/condicoes02.txt}
	\end{block}
	}
	
	\only<6>{
	
	Funções
	\begin{block}{Protótipos e/de Funções}
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\scriptsize]{txtz/funcoes.txt}
	\end{block}
	
	Estruturas
	
	\begin{columns}[T]
		\scriptsize
		\begin{column}{0.5\linewidth}
			\begin{block}{Declaração de Struct}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/struct01.txt}
			\end{block}
        \end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Usando novos tipos de dados}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/struct02.txt}
			\end{block}
		\end{column}
	\end{columns}
	}
	
	\only<7>{
	\framesubtitle{Ponteiros e alocação dinâmica de memória}
	\begin{columns}[T]
	\begin{column}{0.7\linewidth}
	Um dos maiores problemas para programadores iniciantes em C é a questão dos
	ponteiros, para ajudar a entender podemos fazer algumas afirmações:

	\begin{itemize}
		\item A memória é linear.
	\end{itemize}
	\end{column}
	
	\begin{column}{0.3\linewidth}
		\begin{figure}
			\includegraphics[width=100px]{imgs/pointers.png}
		\end{figure}
	\end{column}
	\end{columns}
	
	\begin{block}{Alocação Dinâmica de Memória}
		char *ptr = malloc(100);\\
		int *nptr = malloc(sizeof(int) * 50);\\
		nptr = realloc(nptr, (sizeof(int) * 75));
	\end{block}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{\textbf{Desenvolvendo programas}}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Desenvolvendo programas}
	
	\only<1>{
	Vamos fazer o clássico "Hello World" para começar, ele simplesmente imprime
	o texto na saída do monitor, podemos vêr a estrutura básica de um programa 
	em C e como o compilamos.
	
	\VerbatimInput[xleftmargin=15mm,numbers=left,fontshape=sl,fontsize=\tiny]{txtz/ex02.txt}
	
	Duas coisas a comentar aqui: 
	
	\begin{itemize}
	\item A palavra \#include é utilizada para incluir bibliotecas.
	\item Palavras em C terminam suas declarações com um ';' (ponto e 
	virgula) exceto alguns fluxos de controles como: if, while, else.
	\end{itemize}
	
	\begin{block}{Compilando e rodando o programa}
	\scriptsize
	\$ gcc -o prog1 prog1.c\\
	\$ ./prog1\\
	Ola meu jovem!
	\end{block}
	}
	
	\only<2>{
	Dessa vez vamos complicar um pouquinho mais, o objetivo do programa é encontrar
	entre dois números qual é o maior, para isso separamos o programa em três 
	arquivos distintos:
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{func01.c}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/func01.c}
			\end{block}
			\begin{block}{Como compilar}
				\$ gcc -o func01.o -c func01.c\\
				\$ gcc -o func02.o -c func02.c\\
				\$ gcc -o func func01.o func02.o
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{headers.h}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/headers.h}
			\end{block}
			\begin{block}{func02.c}
				\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/func02.c}
			\end{block}
		\end{column}
	\end{columns}
	}
	
	\only<3>{
	\framesubtitle{Um simples Makefile para projetos pequenos}
	
	Para automatizar nosso processo de compilação em projetos pequenos nós criamos
	um arquivo chamado Makefile. Abaixo podemos ver um exemplo com quatro fontes 
	distintos e três alvos diferentes para o comando 'make'
	
	\begin{block}{Makefile}
		\scriptsize
		\VerbatimInput[xleftmargin=2mm,fontshape=sl,fontsize=\tiny]{txtz/Makefile}
	\end{block}
	
	\vspace{-\baselineskip}
	\begin{columns}[T]
		\tiny
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make clean
			\end{exampleblock}
		\end{column}
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make test
			\end{exampleblock}
		\end{column}
		\begin{column}{0.33\linewidth}
			\begin{exampleblock}{O que este alvo faz?}
				\$ make
			\end{exampleblock}
		\end{column}
	\end{columns}
	}
	
	\only<4> {
		\framesubtitle{Bibliotecas comuns}
		\begin{block}{Compilando código com biblitoecas alternativas}
			
		\end{block}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{\textbf{Utilizando controle de versões}}
	\item \Large{Utilizando o autotools}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Utilizando controle de versões}
	\only<1>{
	Hoje em dia desenvolver qualquer coisa com mais de mil linhas de código sem
	um controlador de versões é confusão na certa, ainda mais se esse código 
	precisa ser compartilhado e desenvolvido por mais de uma pessoa. 
	
	\begin{block}{Definição}
	Como o próprio nome diz ele serve para guardar informações (autor, o que foi
	modificado, quando foi modificado, comentários de porque houve a modificação)
	sobre um determinado arquivo ou projeto em um intervalo de tempo, dando 
	possibilidade aos integradores de juntar versões diferentes ou voltar a uma
	determinada versão gerada em uma linha de tempo.
	\end{block}
	
	Imagine um projeto do tamanho do Linux com mais de 5 milhões de linhas sem um
	controlador de versão para mandar pra dentro o que a galera adiciona ao código!?!?
	}
	
	\only<2>{
	Principais características encontradas nos controladores de versão
	
	\begin{itemize}
		\item Desenvolvimento descentralizado.
		\item Marcações de momentos importantes.
		\item Controle de histórico dos arquivos do projeto.
		\item Linhas de desenvolvimento paralelas(estável, instável) ou branches 
		para adição de novas funcionalidades.
		\item Otimização de espaço, velocidade de transações, locks exclusivos.
	\end{itemize}
	
	Infelizmente não poderemos vêr todas as vantagens aqui, o assunto sobre 
	controle de versões é bastante amplo e deve ficar para uma apresentação 
	específica. Mas vamos a algumas dicas....
	}
	
	\only<3>{
	}
	
	\only<4>{
	GIT, criado por Linus Torvalds.
	
	\begin{columns}[T]
		\tiny
		\begin{column}{0.5\linewidth}
			\begin{block}{Cria um repositório GIT}
			\$ cd projetos/super-secreto \&\& git init
			\end{block}
			
			\begin{block}{Clona um repositório remoto para a máquina local}
			\$ git clone https://github.com/mulatinho/sfm.git 
			\end{block}
			
			\begin{block}{Verifica as mudanças feitas no diretório local}
			\$ git status 
			\end{block}
			
			\begin{block}{Pega as atualizações do repositório original}
			\$ git pull 
			\end{block}
			
			\begin{block}{Mostra as diferenças feitas no arquivo "libsmb.c"}
			\$ git diff libsmb.c 
			\end{block}
		\end{column}
		\begin{column}{0.5\linewidth}
			\begin{block}{Faz commit do arquivo "libsmb.c"}
			\$ git commit -m '2 novas funcoes' libsmb.c 
			\end{block}
			
			\begin{block}{Envia suas modificações ao repositório remoto}
			\$ git push origin master 
			\end{block}
			
			\begin{block}{Lista branchs criadas}
			\$ git branch 
			\end{block}
			
			\begin{block}{Cria branch "cpp-list"}
			\$ git branch cpp-list 
			\end{block}
			
			\begin{block}{Lista todas as tags do repositório}
			\$ git tag -l 
			\end{block}
		\end{column}
	\end{columns}
	\normalsize
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{\textbf{Utilizando o autotools}}
	\item \Large{Debugando seu código}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Utilizando o autotools}
	
	\only<1>{
	Agora imagine se você tivesse que compilar mais de vinte arquivos um a um e 
	depois fazer o link dos objetos na mão, centenas de vezes, quantas vezes você
	erraria a ordem de compilação? esqueceria um ou outro fonte/objeto? Para evitar
	que isso aconteça e que você não precise sempre realizar esse trabalho de 
	maluco, a GNU desenvolveu a ferramenta chamada \textbf{autotools}.
	
	\begin{block}{Quem nunca fez!?}
		\$ ./configure\\
		\$ make\\
		\$ make install
	\end{block}
	
	Apesar de eles serem scripts shell que auxiliam o usuário a gerar o binário
	apartir dos códigos de fonte, eles não são gerados manualmente pelos programadores
	do projeto.
	}
	
	\only<2>{
	Principais módulos da ferramenta autotools
	
	\begin{description}
		\item[Autoconf] Responsável por gerar o arquivo 'configure', muito útil
		na hora de compilar o projeto pois ele checa se todos os pré-requisitos
		foram atentidos, caso não tenham sido ele geralmente retorna ao usuário
		o software, função, etc. que está faltando para compilar o projeto.
		\item[Automake] Apartir dos arquivos de entrada do \texttt{'Makefile.am'}
		ele gera o famoso 'Makefile' que é responsável por processar os comandos
		do usuário 'make' e 'make install'.
		\item[Libtool] Geralmente utilizado em conjunto com o autoconf e o automake,
		o libtool faz a função de cross compiler, apartir das entradas do 
		\texttt{'./configure'} e passando argumentos como \texttt{'--arch'} é
		possível especificar para que arquitetura será compilado o projeto.
	\end{description}
	
	}
	
	\only<3>{
	\framesubtitle{Como utilizar o autotools no seu projeto}
	}
\end{frame}

\begin{frame}
	\frametitle{Agenda}
	\begin{itemize}
	\item \Large{Conceitos Básicos}
	\item \Large{Ferramentas importantes}
	\item \Large{Um pouco de história}
	\item \Large{Uma rápida introdução ao C}
	\item \Large{Desenvolvendo programas}
	\item \Large{Utilizando controle de versões}
	\item \Large{Utilizando o autotools}
	\item \Large{\textbf{Debugando seu código}}
	\end{itemize}
	\normalsize
\end{frame}

\begin{frame}
	\frametitle{Debugando seu código}
	\only<1>{
		\framesubtitle{Utilizando o GDB}
	}
	\only<2>{
		\framesubtitle{Utilizando o strace}
	}
	\only<3>{
		\framesubtitle{Utilizando o ltrace}
	}
	\only<4>{
		\framesubtitle{O pacote binutils}
	}
	\only<5>{
		\framesubtitle{O pacote binutils, parte 2}
	}
\end{frame}

\begin{frame}
	\frametitle{Isso é tudo pessoal!}
    \Huge
    \textbf{Dúvidas?}
    \vskip 10mm
    \normalsize
    Alexandre Mulatinho\\
    Twitter: @alexmulatinho\\
    \space E-mail: alex@mulatinho.net\\
    \space Weblog: http://alex.mulatinho.net\\
\end{frame}

\end{document}
